library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity fsm_rom is
    port (
		  clk: in std_logic;
        entrada: in std_logic;
		  reset: in std_logic;
		  saida: out std_logic_vector (9 downto 0)
    );
end entity;

architecture arch of fsm_rom is
	component rom
		generic
		(
			DATA_WIDTH : natural := 10;
			ADDR_WIDTH : natural := 3
		);

		port (
			clk: in std_logic;
			addr: in natural range 0 to (2**ADDR_WIDTH) -1;
			q: out std_logic_vector (DATA_WIDTH-1 downto 0)
		);
	end component;

	component registrador
		generic
		(
			DATA_WIDTH : natural := 2
		);
		port (
			entrada: in std_logic_vector ((DATA_WIDTH-1) downto 0);
			enable : in std_logic;
			clock: in std_logic;
			reset: in std_logic;
			saida: out std_logic_vector ((DATA_WIDTH-1) downto 0) 
		);
	end component;
	
	signal enable: std_logic;
	signal entrada_reg: std_logic_vector (1 downto 0); --proximo estado
	signal saida_reg: std_logic_vector (1 downto 0); --estado atual
	
	signal addr: std_logic_vector (2 downto 0);
	signal addr_rom: natural; --endere√ßo
	signal saida_rom: std_logic_vector (9 downto 0); --letra + proximo estado
	
begin
	entrada_reg <= saida(1 downto 0);
	
	reg: registrador port map(entrada_reg, '1', clk, reset, saida_reg);
	
	addr <= not(entrada) & saida_reg;
	addr_rom <= to_integer(unsigned(addr));
	
	memoria_rom: rom port map (clk, addr_rom, saida);
	
end arch;